
<h1>{{ question.question_text }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
{% for choice in question.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br />
{% endfor %}
<input type="submit" value="vote" />
</form>

<!--
使用模板
模板系统允许使用点号查找语法来访问变量的属性。在{{ question.question_text }}这个例子中，Django首先在question对象上做字典查询。如果失败，Django会接着尝试属性查询--在这个例子中，属性查询会成功。
如果属性查询也失败，Django将尝试列表索引查询。
方法调用发生在for 循环中：question.choice_set.all被解释为Python的代码:question.choice_set.all()，它返回一个由Choice对象组成的可迭代对象，并将其用于 for 标签。
更多模板的信息：http://python.usyiyi.cn/translate/django_182/topics/templates.html

简要说明：
1、在detail网页模板中，我们为Question对应的每个Choice都添加了一个单选按钮用于选择。每个单选按钮的value属性是对应的各个Choice的ID。
每个单选按钮的name是"choice"。这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中#为选择的Choice的ID。
2、我们设置表单的action为{% url 'polls:vote' question.id %}，并设置method="post"。这个提交表单的行为会改变服务器端的数据。
3、forloop.counter指示for标签已经循环多少次。
4、针对内部URL的POST表单都应该使用{% csrf_token %}模板标签，来处理跨站点请求伪造。

-->